/// The LIR format is used for encoding the Rust code which would be optimized
/// at compile time and the also at runtime. It should mostly be generated by
/// the holyjit driver, and consumed by the holyjit compiler.
///
/// This format is made to optimize for recompilation. Optimizing for
/// recompilation is extremely interesting for a JIT as a JIT work is mostly
/// composed of recompilation. For example, inlining is recompiling a compiled
/// function in another and an invalidation causes a few optimization to be
/// discarded when the same function is recompiled. Optimizing for recompilation
/// implies that we apply versionning ideas on this format, such that the cost
/// of a recompilation is less than the cost of the initial compilation.
///
/// This format is serializable because it has to be saved by the Rust driver,
/// in the data section of the generated program, and read at runtime by the
/// HolyJIT library.
///
/// The LIR is represented as a mix between a Sea-Of-Nodes and SSA, which uses
/// Instruction hashes as SSA indexes. Hashes are used as a way to have a
/// position independent representation to make the versionning effective. The
/// mixed sea-of-nodes approach is used as a way to reduce the number of blocks
/// mutations until we reach the Scheduler.

// Serde is used for serializing and deserializing the LIR which is stored
// by the driver in a constant, and deserialized by the JIT compiler in
// order to be manipulated.
#[macro_use]
extern crate serde_derive;
extern crate serde;
extern crate bincode;

/// Automatically derive a hashing function for each type, to make sure that we
/// can apply patches to a subset of instructions.
use std::hash::{Hash, Hasher};

/// A LIR Unit is a connected set of basic blocks with an entry and exit blocks.
/// This might correspond to a Rust function, a subset of a Rust function which
/// corresponds to an opcode or inline caches, or to an target specific
/// intrinsic abstract code. A Unit contains the set of instructions and blocks
/// which are indexing the instruction in the order in which they are expected
/// to be executed.
#[derive(Serialize, Deserialize, Debug)]
pub struct Unit {
    /// Unique Unit Identifier.
    pub id: UnitId,

    /// Data flow, contains all the instructions and their operands, as well as the potentially memory dependencies.
    pub data_flow: DataFlow,

    /// Control flow, contains all the blocks which are making references to the
    /// data flow instructions, and also the control flow instructions.
    pub control_flow: ControlFlow,
}

/// A Data flow contains all the instructions from one Unit, and they describe
/// how data are flowing through instructions.
#[derive(Serialize, Deserialize, Debug)]
pub struct DataFlow {
    /// Set of instruction, where each instruction should be referenced by at
    /// least a Block using their ValueHash.
    pub instructions: Vec<Instruction>,
}

/// A Control flow contains all the blocks and how they flow from one to
/// another. They reference data flow instructions to determine the order in
/// which side-effectful instructions are expected. They are ending with a
/// control flow instruction.
#[derive(Serialize, Deserialize, Debug)]
pub struct ControlFlow {
    /// List of basic blocks.
    pub blocks: Vec<Block>,
    /// Index of the entry block.
    pub entry: BlockIndex,
    /// Set of exit blocks indexes.
    pub exit: Vec<BlockIndex>,
}

/// Unique Unit identifier of an intrinsic.
type IntrinsicId = usize;
/// Unique unit identifier of a function.
type FunctionId = usize;
/// Unique unit identifier of a sub-set of a function.
type SubSetId = usize;

/// Unique Unit identifier.
#[derive(Serialize, Deserialize, Debug, Hash, Clone, Copy, PartialEq, Eq)]
pub enum UnitId {
    /// Identifier of a pseudo-code of an intrinsic used to represent the
    /// equivalent LIR of a target specific optimization. Intrisic do not have
    /// support for unwinding.
    Intrinsic(IntrinsicId),

    /// Identifier of a callable function.
    Function(FunctionId),

    /// Identifier of a sub-set of a Rust function.
    SubSet(SubSetId)
}


/// A LIR Block Index is an integer which corresponds to an index within a given Unit.
#[derive(Serialize, Deserialize, Debug, Hash)]
pub struct BlockIndex {
    pub value: usize,
}

/// A LIR Block is a sequence of computation of value and a Terminator.
#[derive(Serialize, Deserialize, Debug, Hash)]
pub struct Block {
    /// Sequence of instructions contained in the current block in the order in
    /// which they have to be executed.
    pub sequence: Vec<Value>,
    /// Control flow instruction.
    pub terminator: Value,

    /// Goto's branch, Call's return location and Switch default case.
    pub default: Option<BlockIndex>,
    /// Error handling block, if any error happens during the control flow
    /// instruction.
    pub unwind: Option<BlockIndex>,
    /// Switch targets.
    pub targets: Option<Vec<(isize, BlockIndex)>>,
}

/// A LIR Instruction is a single operation which aggregates operands and an
/// operation to produce a ValueHash.
#[derive(Serialize, Deserialize, Debug)] /* derive(Hash)-manually */
pub struct Instruction {
    /// Opcode of the instruction.
    pub opcode: Opcode,
    /// Ordered list of operands of the instruction.
    pub operands: Vec<Value>,
    /// Set of previous instructions which might change the memory read by this
    /// instruction.
    pub dependencies: Vec<Value>,
    /// Set if this instruction got replaced by another. This is not taken into
    /// account while computing the hash of an instruction.
    pub replaced_by: Option<Value>,
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy)] /* derive(Hash)-manually */
pub enum ConstData {
    Unsigned(u64),
    Signed(i64),
    Float(f64),
}
#[derive(Serialize, Deserialize, Debug, Hash, Clone, Copy)]
pub struct SwitchData {
    pub low: i32,
    pub high: i32,
}

/// An Opcode is an instruction which contains basic operations. This list of
/// opcode is minimal and contains all the building blocks to express higher
/// level IR instructions which are platform specific as intrinsic units.
#[derive(Serialize, Deserialize, Debug, Hash, Clone, Copy)]
pub enum Opcode {
    /// WithHash is a way to wrap a Value with another ValueHash which will be
    /// used either for loop-back or to limit the amount of context referrenced
    /// in a patch.
    /// (1 operand)
    Rehash(usize),

    /// Phi is an instruction which merges values from different blocks. Note
    /// that this LIR uses Phi instead of extended basic block, in order to
    /// avoid carrying around too many variables to the next block, which would
    /// imply additional rewrite of the graphs on inlining.
    /// (multiple operands)
    Phi,

    /// Encode a constant.
    /// (0 operand + data_index to ConstData)
    Const(ConstData),

    /// Cast is used to change the type interpretation of a Value without any content checks.
    /// (1 operand + data_index to CastData)
    Cast(ComplexTypeId),

    /// Extract overflow flag from the operation which created the value.
    /// (0 operand, 1 dependency)
    OverflowFlag,

    /// Addition. (2 operands)
    Add(NumberType),
    /// Substraction. (2 operands: result = lhs - rhs)
    Sub(NumberType),
    /// Multiplication. (2 operands)
    Mul(NumberType),
    /// Division. (2 operands: result = lhs / rhs)
    Div(NumberType),
    /// Remainder. (2 operands: result = lhs % rhs)
    Rem(NumberType),
    /// Sign-extend. (1 operand)
    SignExt(SignedType),
    /// Zero-extend. (1 operand)
    ZeroExt(IntType),

    /// Truncate. (round towards zero) (1 operand)
    Truncate(FloatType),
    /// Round. (round towards nearest) (1 operand)
    Round(FloatType),
    /// Floor. (round towards -Inf) (1 operand)
    Floor(FloatType),
    /// Ceil. (round towards +Inf) (1 operand)
    Ceil(FloatType),

    /// Bitwise exclusive or. (2 operands)
    BwXor(IntType),
    /// Bitwise And. (2 operands)
    BwAnd(IntType),
    /// Bitwise Or. (2 operands)
    BwOr(IntType),
    /// Bitwise Not. (2 operands)
    BwNot(IntType),
    /// Shift left. (2 operands: result = lhs << rhs)
    ShiftLeft(IntType),
    /// Shift right. (2 operands: result = lhs >> rhs)
    ShiftRight(SignedType),

    /// Equal. (2 operands)
    Eq(NumberType),
    /// Less than. (2 operands: result = lhs < rhs)
    Lt(NumberType),
    /// Less than or equal. (2 operands: result = lhs <= rhs)
    Le(NumberType),
    /// Not equal. (2 operands)
    Ne(NumberType),
    /// Greather than. (2 operands: result = lhs > rhs)
    Gt(NumberType),
    // Greather than or equal. (2 operands: result = lhs >= rhs)
    Ge(NumberType),

    /// StaticAddress is used to refer to data which is not yet known at compile
    /// time, but known at the execution, such as function pointer addresses.
    /// (0 operand)
    StaticAddress,
    /// CPUAddress is used to refer to internal CPU data, and help the compiler
    /// reason about the aliasing intrinsic using CPU data, such as flags and
    /// cpuid.
    /// (0 operand)
    CPUAddress,
    /// Get the address of where the input operand is stored. At the end of the
    /// pipeline, if any of these instructions remain it enforces the data to
    /// live in memory at least as long as the address exists.
    /// (1 operand)
    Address,

    /// Load content from the address. (1 operand: result = *input, data_index)
    Load(ComplexTypeId),
    /// Store content to the address. (2 operands: *lhs = rhs, data_index)
    Store(ComplexTypeId),

    // Acquire = LoadFence{Load, Store}
    // Release = {Load, Store}FenceStore

    /// LoadFenceLoad or read barrier implies that all loads must be completed
    /// before proceeding with any loads. (Prevent the compiler from moving load
    /// instructions) (0 operand)
    LoadFenceLoad,
    /// LoadFenceStore implies that all loads must be completed before
    /// proceeding with any stores. (Prevent the compiler from moving load and
    /// store instructions) (0 operand)
    LoadFenceStore,
    /// StoreFenceLoad implies that all stores must be completed before
    /// proceeding with any loads. (Prevent the compiler from moving load and
    /// store instructions) (0 operand)
    StoreFenceLoad,
    /// StoreFenceStore or write barrier implies that all stores must be
    /// completed before proceeding with any stores. (Prevent the compiler from
    /// moving store instructions) (0 operand)
    StoreFenceStore,

    /// Unit is used for non fallible unit. For example, this can be used for
    /// non-inlinable and non-optimizable intrinsics which are expressed in
    /// terms of the minimal set of instructions. This is used to provide target
    /// specific instructions such as SIMD, locked-instructions or cpuid which
    /// are not represented in this LIR. (maybe operands)
    Unit(UnitId),

    //
    // List of Control instructions.
    //

    /// Return the value computed by the instruction behind Value. This
    /// corresponds either to the returned value of a function, or to the result
    /// of an expression for subset of Rust functions.
    /// (1 operand)
    Return,

    /// Unwind ends the control flow, and unwind everything.
    Unwind,

    /// Unreachable is used either as an assertion / optimization mechanism.
    Unreachable,

    /// Goto is an unconditional jump to another basic block in the same Unit.
    /// (0 operand, default target)
    Goto,

    /// Switch is a conditional branch implemented as a switch case over
    /// variable ranges of integer values. This is used even for simple if/else
    /// branches.
    /// (1 operand, maybe default target, targets)
    Switch(SwitchData),

    /// Call implements a function call, such as any Rust function, an assertion
    /// or a drop function.
    /// (many operands: function + arguments, maybe default target, maybe unwind target)
    Call,

    /// CallUnit implements an internal Unit call or inline.
    /// (many operands: arguments, maybe default target, maybe unwind target)
    CallUnit(UnitId),
}

/// NumberType are used for math and bitwise operators.
#[derive(Serialize, Deserialize, Debug, Hash, Clone, Copy)]
pub enum NumberType {
    I(SignedType),
    F(FloatType),
}
#[derive(Serialize, Deserialize, Debug, Hash, Clone, Copy)]
pub enum IntType {
    I8, I16, I32, I64,
}
#[derive(Serialize, Deserialize, Debug, Hash, Clone, Copy)]
pub enum SignedType {
    S(IntType),
    U(IntType),
}
#[derive(Serialize, Deserialize, Debug, Hash, Clone, Copy)]
pub enum FloatType {
    F32, F64,
}

/// ComplexType indexes are used to index an arithmetic type or an aggregated
/// type, such as tuples, enums or structures within the Assembly.
type ComplexTypeId = usize;

/// A LIR Value corresponds to the computation of either instructions or
/// terminator. As opposed to ordinary SSA notation, we use a hash instead of an
/// instruction index, in order to be able to generate position-independent
/// patches for each Unit.
#[derive(Serialize, Deserialize, Debug, Hash, Clone, Copy)]
pub struct Value {
    pub hash: u64,
    pub index: usize,
}

impl Opcode {
    pub fn is_control(self) -> bool {
        match self {
            Opcode::Return |
            Opcode::Unwind |
            Opcode::Unreachable |
            Opcode::Goto |
            Opcode::Switch(_) |
            Opcode::Call |
            Opcode::CallUnit(_) => true,
            _ => false,
        }
    }
}

impl Hash for ConstData {
    fn hash<H : Hasher>(&self, state: &mut H) {
        use std::mem;
        mem::discriminant(self).hash(state);
        match self {
            &ConstData::Unsigned(v) => v.hash(state),
            &ConstData::Signed(v) => v.hash(state),
            &ConstData::Float(v) => {
                assert_eq!(mem::size_of::<f64>(), mem::size_of::<u64>());
                assert_eq!(mem::align_of::<f64>(), mem::align_of::<u64>());
                let v : u64 = unsafe { mem::transmute_copy(&v) };
                v.hash(state);
            }
        }
    }
}

impl Hash for Instruction {
    fn hash<H : Hasher>(&self, state: &mut H) {
        self.opcode.hash(state);
        self.operands.hash(state);
        self.dependencies.hash(state);
        // Exclude self.replaced_by.
    }
}

impl<'a> From<&'a Instruction> for u64 {
    fn from(ins: &'a Instruction) -> u64 {
        use std::collections::hash_map::DefaultHasher;
        let mut hasher = DefaultHasher::new();
        ins.hash(&mut hasher);
        hasher.finish()
    }
}

impl Unit {
    pub fn new(id: UnitId) -> Unit {
        Unit {
            id,
            data_flow: DataFlow::new(),
            control_flow: ControlFlow::new(),
        }
    }
}

impl ControlFlow {
    pub fn new() -> ControlFlow {
        ControlFlow {
            blocks: vec![],
            entry: BlockIndex { value: 0 },
            exit: vec![],
        }
    }
}

impl DataFlow {
    pub fn new() -> DataFlow {
        DataFlow { instructions: vec![] }
    }

    fn get_value(&self, index: usize) -> Value {
        Value { hash: (&self.instructions[index]).into(), index }
    }

    pub fn add_ins(&mut self, ins: Instruction) -> Value {
        // TODO: Ensure that if the instruction already exists, then it is not
        // being added a second time, and the returned Value output correspond
        // to the existing Instruction.
        // TODO: Add consistency checks that all value references are indeed in
        // the current DataFlow structure.
        self.instructions.push(ins);
        self.get_value(self.instructions.len() - 1)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn check_rehash() {
        let mut df = DataFlow::new();
        let v0 = df.add_ins(Instruction {
            opcode: Opcode::Const(ConstData::Unsigned(1024)),
            operands: vec![],
            dependencies: vec![],
            replaced_by: None,
        });
        let v1 = df.add_ins(Instruction {
            opcode: Opcode::Rehash(21),
            operands: vec![v0],
            dependencies: vec![],
            replaced_by: None,
        });
        let v2 = df.add_ins(Instruction {
            opcode: Opcode::Rehash(69),
            operands: vec![v0],
            dependencies: vec![],
            replaced_by: None,
        });
        // Rehash opcode compute a different hash value based on the number
        // which is given as argument. This is used to handle loops.
        assert_ne!(v1.hash, v2.hash);
    }

    #[test]
    fn check_replaced_by() {
        let mut df = DataFlow::new();
        let v0 = df.add_ins(Instruction {
            opcode: Opcode::Const(ConstData::Unsigned(1)),
            operands: vec![],
            dependencies: vec![],
            replaced_by: None,
        });
        let v1 = df.add_ins(Instruction {
            opcode: Opcode::Add(NumberType::I(SignedType::U(IntType::I32))),
            operands: vec![v0, v0],
            dependencies: vec![],
            replaced_by: None,
        });
        let v2 = df.add_ins(Instruction {
            opcode: Opcode::Const(ConstData::Unsigned(2)),
            operands: vec![v0],
            dependencies: vec![],
            replaced_by: None,
        });
        df.instructions[v1.index].replaced_by = Some(v2);
        // When setting the replaced_by field, the hash of an instruction should
        // not change.
        assert_eq!(v1.hash, df.get_value(v1.index).hash);
    }
}
